import json
from pathlib import Path
from typing import Any, Dict, List, Optional, Union

from haystack import component, default_from_dict, default_to_dict, logging
from haystack.components.generators.chat import ChatGenerator
from haystack.dataclasses import ChatMessage, ChatRole
from haystack.lazy_imports import LazyImport
from haystack.utils.class_loading import load_class

logger = logging.getLogger(__name__)

with LazyImport("Run 'pip install openapi-service-client'") as openapi_imports:
    from openapi_service_client import ClientConfigurationBuilder, OpenAPIServiceClient
    from openapi_service_client.providers import AnthropicLLMProvider, CohereLLMProvider, OpenAILLMProvider


@component
class OpenAPITool:
    """
    The OpenAPITool calls an OpenAPI service using payloads generated by the chat generator from human instructions.

    The OpenAPITool component is initialized with a chat generator and an optional OpenAPI specification for the
    tool/service.The chat generator is used to generate the function calling payload from human instructions that is
    then used to invoke the OpenAPI service/tool. ChatGenerator can be any of Haystack chat generators that supports
    function calling including OpenAIChatGenerator, AnthropicChatGenerator, CohereChatGenerator etc.

    Here is an example of how to use the OpenAPITool component to scrape a URL using the FireCrawl API:

    ```python
    from haystack.components.tools import OpenAPITool
    from haystack.components.generators.chat.openai import OpenAIChatGenerator
    from haystack.dataclasses import ChatMessage

    tool = OpenAPITool(chat_generator=OpenAIChatGenerator(),
                       tool_spec="https://raw.githubusercontent.com/mendableai/firecrawl/main/apps/api/openapi.json",
                       tool_credentials="<your-tool-token>")

    results = tool.run(messages=[ChatMessage.from_user("Scrape URL: https://news.ycombinator.com/")])
    print(results)
    ```

    Similarly, you can use the OpenAPITool component to use any OpenAPI service/tool by providing the OpenAPI
    specification and credentials.
    """

    def __init__(
        self,
        chat_generator: ChatGenerator,
        tool_spec: Optional[Union[str, Path]] = None,
        tool_credentials: Optional[Union[str, Dict[str, Any]]] = None,
        provider_map: Optional[Dict[str, Any]] = None,
        default_provider: Optional[str] = None,
    ):
        openapi_imports.check()

        self.provider_map = provider_map or {
            "openai": OpenAILLMProvider(),
            "anthropic": AnthropicLLMProvider(),
            "cohere": CohereLLMProvider(),
        }
        default_provider = default_provider or self._extract_provider(chat_generator)
        if default_provider not in self.provider_map:
            raise ValueError(f"Default provider {default_provider} not found in provider map.")
        self.chat_generator = chat_generator
        self.llm_provider = self.provider_map.get(default_provider)
        if tool_spec:
            builder = ClientConfigurationBuilder()
            self.config_openapi = (
                builder.with_openapi_spec(tool_spec)
                .with_provider(self.llm_provider)
                .with_credentials(tool_credentials)
                .build()
            )
        else:
            self.config_openapi = None

    @component.output_types(service_response=List[ChatMessage])
    def run(
        self,
        messages: List[ChatMessage],
        fc_generator_kwargs: Optional[Dict[str, Any]] = None,
        tool_spec: Optional[Union[str, Path, Dict[str, Any]]] = None,
        tool_credentials: Optional[Union[dict, str]] = None,
    ) -> Dict[str, List[ChatMessage]]:
        """
        Invokes the underlying OpenAPI service/tool with the function calling payload generated by the chat generator.

        :param messages: List of ChatMessages to generate function calling payload (e.g. human instructions).
        :param fc_generator_kwargs: Additional arguments for the function calling payload generation process.
        :param tool_spec: OpenAPI specification for the tool/service.
        :param tool_credentials: Credentials for the tool/service.
        :returns: a dictionary containing the service response with the following key:
            - `service_response`: List of ChatMessages containing the service response.
        """
        last_message = messages[-1]
        if not last_message.is_from(ChatRole.USER):
            raise ValueError(f"{last_message} not from the user")
        if not last_message.content:
            raise ValueError("Function calling instruction message content is empty.")

        # build a new ClientConfiguration if a runtime tool_spec is provided
        config_openapi = (
            ClientConfigurationBuilder()
            .with_openapi_spec(tool_spec)
            .with_credentials(tool_credentials)
            .with_provider(self.llm_provider)
            .build()
            if tool_spec
            # otherwise use the one provided at initialization
            else self.config_openapi
        )
        if not config_openapi:
            raise ValueError(
                "OpenAPI specification not provided. Please provide an OpenAPI specification either at initialization "
                "or during runtime."
            )
        # merge fc_generator_kwargs, tools definitions comes from the OpenAPI spec, other kwargs are passed by the user
        fc_generator_kwargs = {"tools": config_openapi.get_tools_definitions(), **(fc_generator_kwargs or {})}

        # generate function calling payload with the chat generator
        logger.debug(f"Invoking chat generator with {last_message.content} to generate function calling payload.")
        fc_payload = self.chat_generator.run(messages, fc_generator_kwargs)

        openapi_service = OpenAPIServiceClient(config_openapi)
        try:
            invocation_payload = json.loads(fc_payload["replies"][0].content)
            logger.debug(f"Invoking tool {config_openapi.get_openapi_spec().get_name()} with {invocation_payload}")
            service_response = openapi_service.invoke(invocation_payload)
        except Exception as e:
            logger.error(f"Error invoking OpenAPI endpoint. Error: {e}")
            service_response = {"error": str(e)}
        response_messages = [ChatMessage.from_user(json.dumps(service_response))]
        return {"service_response": response_messages}

    def _extract_provider(self, chat_generator: ChatGenerator) -> str:
        """
        Extract the provider name from the chat generator class name.

        :param chat_generator: ChatGenerator instance.
        :return: Provider name.
        """
        chat_generator_class_name = type(chat_generator).__name__
        if "Anthropic" in chat_generator_class_name:
            return "anthropic"
        elif "Cohere" in chat_generator_class_name:
            return "cohere"
        return "openai"

    def to_dict(self) -> Dict[str, Any]:
        """
        Serialize this component to a dictionary.

        :returns:
            The serialized component as a dictionary.
        """
        return default_to_dict(
            self,
            chat_generator=self.chat_generator.to_dict(),
            tool_spec=self.config_openapi.get_openapi_spec().to_dict(),
        )

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "OpenAPITool":
        """
        Deserialize this component from a dictionary.

        :param data: The dictionary representation of this component.
        :returns:
            The deserialized component instance.
        """
        chat_generator_type = data["init_parameters"]["chat_generator"]["type"]
        chat_generator_class = load_class(chat_generator_type)
        chat_generator = chat_generator_class.from_dict(data["init_parameters"]["chat_generator"])
        data["init_parameters"]["chat_generator"] = chat_generator
        return default_from_dict(cls, data)
